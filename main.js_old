
import * as THREE from 'three';

import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import { TransformControls } from 'three/addons/controls/TransformControls.js';
import { GUI } from 'lil-gui';
import { loadBlockState, blockStateStringParser, assetsPath, bs } from './BlockModelLoader.js';
import { InfiniteGridHelper } from './InfiniteGridHelper';

//import * as BufferGeometryUtils from 'three/addons/utils/BufferGeometryUtils.js';

let cameraPersp, cameraOrtho, currentCamera;
let scene, renderer, control, orbit;
let objects, currentObject;
let transformsGUI, elementsGUI, toolsGUI1, toolsGUI2, toolsGUI3, toolsGUI4, searchGUI, commandGUI;

let shiftDown = false;
let ctrlDown = false;

let clipboard = [];

let historyMaxLength = 10;
let history = [];
let historyIndex = 0;

let sel = {
    _selected: false,
    get() {
        return this._selected;
    },
    set(b) {
        this._selected = b;
        if (b) {
            let color = (this.isCollection) ? 0x00ff00 : 0xffff00;
            if (this.isCollection) {
                this.getObjectsByProperty('isBoundingBox', true)[0].visible = true;
            } else if (this.isBlockDisplay) {
                const box = new THREE.Box3();
                box.setFromCenterAndSize(new THREE.Vector3(0.5 - 0.001, 0.5 - 0.001, 0.5 - 0.001), new THREE.Vector3(1 + 0.001, 1 + 0.001, 1 + 0.001));

                const helper = new THREE.Box3Helper(box, color);
                helper.isBoundingBox = true;
                this.add(helper);
            }
        } else {
            if (this.isCollection) {
                this.getObjectsByProperty('isBoundingBox', true)[0].visible = false;
            } else if (this.isBlockDisplay) {
                let boxes = this.getObjectsByProperty('isBoundingBox', true);
                for (let box of boxes) {
                    this.remove(box);
                }
            }

        }
        return this._selected;
    }
};



init();
render();

async function init() {

    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const aspect = window.innerWidth / window.innerHeight;

    cameraPersp = new THREE.PerspectiveCamera(50, aspect, 0.01, 30000);
    cameraOrtho = new THREE.OrthographicCamera(- 6 * aspect, 6 * aspect, 6, - 6, 0.0001, 30000);
    currentCamera = cameraPersp;

    currentCamera.position.set(-3, 3, -3);
    currentCamera.lookAt(0, 0, 0);

    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x111111)

    // Adding grid helper
    const grid = new InfiniteGridHelper(4, 64, new THREE.Color(0.2, 0.2, 0.2));
    grid.scale.set(1 / 64, 1 / 64, 1 / 64);
    grid.position.set(0, -0.001, 0);
    scene.add(grid);

    // Adding axes helper
    const axesHelper = new THREE.AxesHelper(50);
    scene.add(axesHelper);

    // Adding box helper
    const box = new THREE.Box3();
    box.setFromCenterAndSize(new THREE.Vector3(0.5, 0.5, 0.5), new THREE.Vector3(0.9999, 0.9999, 0.9999));
    const helper = new THREE.Box3Helper(box, 0x444444);
    scene.add(helper);

    // Lights

    scene.add(new THREE.AmbientLight(0xCCCCCC));
    const light = new THREE.DirectionalLight(0xffffff, 0.5);
    light.position.set(1, 1.5, 0.5);
    scene.add(light);



    orbit = new OrbitControls(currentCamera, renderer.domElement);
    orbit.update();
    orbit.addEventListener('change', render);

    control = new TransformControls(currentCamera, renderer.domElement);
    control.addEventListener('change', render);

    control.addEventListener('dragging-changed', function (event) {

        orbit.enabled = !event.value;

    });
    control.setTranslationSnap(1 / 16);
    control.setRotationSnap(THREE.MathUtils.degToRad(15));
    control.setScaleSnap(1 / 16);

    objects = new THREE.Group();
    scene.add(objects);
    currentObject = objects;

    scene.add(control);

    window.addEventListener('resize', onWindowResize);


    initGUI();

    //let test = [
    //    'oak_fence[north=true,south=true,west=true]',
    //    //        'cake',
    //    //        'cauldron',
    //    //        'lectern',
    //    //        'big_dripleaf[tilt=full]',
    //    //        'lever',
    //    //        'azalea',
    //    //        'flower_pot',
    //    //        'cartography_table',
    //    //        'campfire',
    //    //        'quartz_stairs[facing=east,shape=straight]'
    //];
    //let counter = 0;
    //for (let bs of test) {
    //    await addBlockDisplay(bs, [counter * 2 - test.length, 0, 0]);
    //    counter++;
    //}

    initControls();

    window.addEventListener("load", async function (e) {
        let json = await decompressJSON(localStorage.getItem('blockDisplayObjects'));
        await objectsFromJSON(json);
        render();
        updateElementsGUI();
    });
    window.addEventListener("beforeunload", async function (e) {
        localStorage.setItem('blockDisplayObjects', await compressJSON(objectsToJSON()));
    });
}

function initControls() {
    window.addEventListener('keydown', async function (event) {

        switch (event.keyCode) {

            case 81: // Q
                control.setSpace(control.space === 'local' ? 'world' : 'local');
                break;

            case 16: // Shift
                control.setTranslationSnap(null);
                control.setRotationSnap(null);
                control.setScaleSnap(null);
                shiftDown = true;
                break;

            case 17: // Ctrl
                ctrlDown = true;
                break;

            case 84: // T
                control.setMode('translate');
                break;

            case 82: // R
                control.setMode('rotate');
                break;

            case 83: // S
                control.setMode('scale');
                break;

            case 79: // O
                const position = currentCamera.position.clone();

                currentCamera = currentCamera.isPerspectiveCamera ? cameraOrtho : cameraPersp;
                currentCamera.position.copy(position);

                orbit.object = currentCamera;
                control.camera = currentCamera;

                currentCamera.lookAt(orbit.target.x, orbit.target.y, orbit.target.z);
                onWindowResize();
                break;

            case 107: // +, =, num+
                control.setSize(control.size + 0.1);
                break;

            case 189:
            case 109: // -, _, num-
                control.setSize(Math.max(control.size - 0.1, 0.1));
                break;

            case 88: // X
                control.showX = !control.showX;
                break;

            case 89: // Y
                control.showY = !control.showY;
                break;

            case 90: // Z
                control.showZ = !control.showZ;
                break;

            case 32: // Spacebar
                control.enabled = !control.enabled;
                break;

            case 27: // Esc
                control.reset();
                break;

            case 46: // Del
                deleteBlockDisplay();
                updateElementsGUI();
                render();
                updateHistory();
                break;

            case 67: // C
                if (ctrlDown) {
                    let selected = objects.getObjectsByProperty('selected', true);
                    if (selected.length) {
                        clipboard = await duplicateBlockDisplay(selected, false);
                    }
                }
                break;

            case 86: // V
                if (ctrlDown) {
                    const duplicates = await duplicateBlockDisplay(clipboard);
                    selectBlockDisplay();
                    for (let object of duplicates) {
                        object.selected = true;
                    }
                    updateElementsGUI();
                    render();
                }
                break;

            case 71: // G

                toggleGrouping();
                updateElementsGUI();
                render();

                break;

            case 65: // A


                for (let object of objects.children) {
                    object.selected = true;
                }
                render();

                break;

        };

    });

    window.addEventListener('keyup', function (event) {

        switch (event.keyCode) {

            case 16: // Shift
                control.setTranslationSnap(1 / 16);
                control.setRotationSnap(THREE.MathUtils.degToRad(15));
                control.setScaleSnap(1 / 16);
                shiftDown = false;
                break;

            case 17: // Ctrl
                ctrlDown = false;
                break;

        }

    });

    let mouse;

    renderer.domElement.addEventListener('mousedown', function (event) {
        mouse = [event.clientX, event.clientY];
    });


    renderer.domElement.addEventListener('mouseup', function (event) {
        let prevMouse = mouse;
        mouse = [event.clientX, event.clientY];
        if (!arrayEquals(prevMouse, mouse)) { return };

        let mouseVector = new THREE.Vector2((event.clientX / window.innerWidth) * 2 - 1,
            -(event.clientY / window.innerHeight) * 2 + 1);

        var raycaster = new THREE.Raycaster();
        raycaster.setFromCamera(mouseVector, currentCamera);
        var intersects = raycaster.intersectObjects(objects.children, true);
        for (let intersection of intersects) {
            let object = intersection.object;
            if (object.isBoundingBox) {
                continue;
            } else {
                while (!(object.parent === objects)) {
                    object = object.parent;
                }
                selectBlockDisplay(object);
                updateElementsGUI();
                render();
                return;
            }

        }

        selectBlockDisplay();
        updateElementsGUI();
        render();
    });
}

function initGUI() {
    // ELEMENTS

    elementsGUI = new GUI({ autoPlace: false, title: 'Elements' });
    elementsGUI.domElement.id = 'elementsGUI';
    document.getElementById('side_container').appendChild(elementsGUI.domElement);

    // TRANSFORMS

    transformsGUI = new GUI({ title: 'Transforms', autoPlace: false });
    document.getElementById('side_container').appendChild(transformsGUI.domElement);
    transformsGUI.hide();

    const folderPosition = transformsGUI.addFolder('Position');
    const propsPosition = {

        get 'X'() {

            return currentObject.position.x;

        },
        set 'X'(v) {

            currentObject.position.setX(v);
            render();

        },

        get 'Y'() {

            return currentObject.position.y;

        },
        set 'Y'(v) {

            currentObject.position.setY(v);
            render();

        },

        get 'Z'() {

            return currentObject.position.z;

        },
        set 'Z'(v) {

            currentObject.position.setZ(v);
            render();

        },

    };
    folderPosition.add(propsPosition, 'X', -1, 1, 1 / 16).listen();
    folderPosition.add(propsPosition, 'Y', -1, 1, 1 / 16).listen();
    folderPosition.add(propsPosition, 'Z', -1, 1, 1 / 16).listen();

    const folderRotation = transformsGUI.addFolder('Rotation');
    const propsRotation = {

        get 'X'() {

            return currentObject.rotation.x;

        },
        set 'X'(v) {

            currentObject.rotation.x = v;
            render();

        },

        get 'Y'() {

            return currentObject.rotation.y;

        },
        set 'Y'(v) {

            currentObject.rotation.y = v;
            render();

        },

        get 'Z'() {

            return currentObject.rotation.z;

        },
        set 'Z'(v) {

            currentObject.rotation.z = v;
            render();

        },

    };
    folderRotation.add(propsRotation, 'X', -Math.PI, Math.PI, Math.PI / 12).listen();
    folderRotation.add(propsRotation, 'Y', -Math.PI, Math.PI, Math.PI / 12).listen();
    folderRotation.add(propsRotation, 'Z', -Math.PI, Math.PI, Math.PI / 12).listen();

    const folderScale = transformsGUI.addFolder('Scale');
    const propsScale = {

        get 'X'() {

            return currentObject.scale.x;

        },
        set 'X'(v) {

            currentObject.scale.setX(v);
            render();

        },

        get 'Y'() {

            return currentObject.scale.y;

        },
        set 'Y'(v) {

            currentObject.scale.setY(v);
            render();

        },

        get 'Z'() {

            return currentObject.scale.z;

        },
        set 'Z'(v) {

            currentObject.scale.setZ(v);
            render();

        },

    };
    folderScale.add(propsScale, 'X', 0, 1, 1 / 16).listen();
    folderScale.add(propsScale, 'Y', 0, 1, 1 / 16).listen();
    folderScale.add(propsScale, 'Z', 0, 1, 1 / 16).listen();



    // TOOLS

    toolsGUI1 = new GUI({ autoPlace: false, title: '' });
    toolsGUI1.domElement.id = 'toolsGUI';
    document.getElementById('tool_container').appendChild(toolsGUI1.domElement);

    toolsGUI2 = new GUI({ autoPlace: false, title: '' });
    toolsGUI2.domElement.id = 'toolsGUI';
    document.getElementById('tool_container').appendChild(toolsGUI2.domElement);

    toolsGUI3 = new GUI({ autoPlace: false, title: '' });
    toolsGUI3.domElement.id = 'toolsGUI';
    document.getElementById('tool_container').appendChild(toolsGUI3.domElement);

    toolsGUI4 = new GUI({ autoPlace: false, title: '' });
    toolsGUI4.domElement.id = 'toolsGUI';
    document.getElementById('tool_container').appendChild(toolsGUI4.domElement);

    const propTools = {
        // Load
        '<i class="bi bi-folder2-open"></i>'() {
            loadBlockDisplaysFromFile();
        },
        // Save
        '<i class="bi bi-save"></i>'() {
            saveBlockDisplaysToFile();
        },
        // Undo
        '<i class="bi bi-arrow-counterclockwise"></i>'() {
            undo();
            updateElementsGUI();
            render();
        },
        // Redo
        '<i class="bi bi-arrow-clockwise"></i>'() {
            redo();
            updateElementsGUI();
            render();
        },

        // Add
        '<i class="bi bi-plus-square-fill"></i>'() {
            searchGUI.open();
        },
        // Duplicate
        '<i class="bi bi-intersect"></i>': async function () {
            const duplicates = await duplicateBlockDisplay();
            selectBlockDisplay();
            for (let object of duplicates) {
                object.selected = true;
            }
            updateElementsGUI();
            render();
        },
        // Group
        '<i class="bi bi-collection-fill"></i>'() {
            toggleGrouping();
            updateElementsGUI();
            render();
        },
        // Delete
        '<i class="bi bi-trash-fill"></i>'() {
            deleteBlockDisplay();
            updateElementsGUI();
            render();
        },

        // Translate
        '<i class="bi bi-arrows-move"></i>'() {
            control.setMode('translate');
        },
        // Rotate
        '<i class="bi bi-arrow-repeat"></i>'() {
            control.setMode('rotate');
        },
        // Scale
        '<i class="bi bi-arrows-angle-expand"></i>'() {
            control.setMode('scale');
        },

        // Generate code
        '<i class="bi bi-code-slash"></i>'() {
            updateCommandGUI();
            commandGUI.open();
        },
    };

    toolsGUI1.add(propTools, '<i class="bi bi-folder2-open"></i>').domElement.title = 'Load';
    toolsGUI1.add(propTools, '<i class="bi bi-save"></i>').domElement.title = 'Save';
    toolsGUI1.add(propTools, '<i class="bi bi-arrow-counterclockwise"></i>').domElement.title = 'Undo';
    toolsGUI1.add(propTools, '<i class="bi bi-arrow-clockwise"></i>').domElement.title = 'Redo';

    toolsGUI2.add(propTools, '<i class="bi bi-plus-square-fill"></i>').domElement.title = 'Add Block Display';
    toolsGUI2.add(propTools, '<i class="bi bi-intersect"></i>').domElement.title = 'Duplicate Selected';
    toolsGUI2.add(propTools, '<i class="bi bi-collection-fill"></i>').domElement.title = 'Group / Ungroup Selected (G)';
    toolsGUI2.add(propTools, '<i class="bi bi-trash-fill"></i>').domElement.title = 'Delete Selected (DEL)';

    toolsGUI3.add(propTools, '<i class="bi bi-arrows-move"></i>').domElement.title = 'Translate Tool (T)';
    toolsGUI3.add(propTools, '<i class="bi bi-arrow-repeat"></i>').domElement.title = 'Rotate Tool (R)';
    toolsGUI3.add(propTools, '<i class="bi bi-arrows-angle-expand"></i>').domElement.title = 'Scale Tool (S)';

    toolsGUI4.add(propTools, '<i class="bi bi-code-slash"></i>').domElement.title = 'Generate Summon Command';

    // SEARCH

    searchGUI = new GUI({ title: 'Block Search', autoPlace: false });
    document.getElementById('top_container').appendChild(searchGUI.domElement);
    searchGUI.domElement.id = 'searchGUI';
    searchGUI.close();

    const propsSearch = {
        searchTerm: '',
        get 'text'() {

            return this.searchTerm;

        },
        set 'text'(v) {

            updateSearchGUI(v);
            this.searchTerm = v;

        },
    }

    searchGUI.add(propsSearch, 'text').name('Search').listen();
    const folderResults = searchGUI.addFolder('Results');
    updateSearchGUI('');

    // COMMAND

    commandGUI = new GUI({ title: 'Command', autoPlace: false });
    document.getElementById('top_container').appendChild(commandGUI.domElement);
    commandGUI.domElement.id = 'commandGUI';
    commandGUI.close();

    const propsCommand = {
        'command': '',
        'Generate Command': async function () {
            await updateCommandGUI();
        }
    }
    //let command = commandGUI.add(propsCommand, 'command').name('Command');
    let textarea = document.createElement('textarea');
    textarea.classList.add('children');
    textarea.setAttribute('readOnly', true);
    commandGUI.domElement.appendChild(textarea);
    commandGUI.add(propsCommand, 'Generate Command');

    // HELP

    const helpGUI = new GUI({ autoPlace: false, title: 'Controls (Help)' });
    helpGUI.domElement.id = 'helpGUI';
    document.getElementById('side_container').appendChild(helpGUI.domElement);
    helpGUI.close();

    const folderSelect = helpGUI.addFolder('Object operations');
    folderSelect.add({ 'Select object': 'LEFTCLICK' }, 'Select object').disable();
    folderSelect.add({ 'Select multiple': 'SHIFT + LEFTCLICK' }, 'Select multiple').disable();
    folderSelect.add({ 'Select all': 'A' }, 'Select all').disable();
    folderSelect.add({ 'Delete selected': 'DEL' }, 'Delete selected').disable();
    folderSelect.add({ 'Group / Ungroup selected': 'G' }, 'Group / Ungroup selected').disable();
    folderSelect.add({ 'Copy selected': 'CTRL + C' }, 'Copy selected').disable();
    folderSelect.add({ 'Paste copy': 'CTRL + V' }, 'Paste copy').disable();

    const folderCamera = helpGUI.addFolder('Camera control');
    folderCamera.add({ 'Rotate': 'LEFTMOUSEBUTTON' }, 'Rotate').disable();
    folderCamera.add({ 'Zoom': 'MIDDLEMOUSEBUTTON' }, 'Zoom').disable();
    folderCamera.add({ 'Pan': 'RIGHTMOUSEBUTTON' }, 'Pan').disable();
    folderCamera.add({ 'Othographic camera': 'O' }, 'Othographic camera').disable();

    const folderEditing = helpGUI.addFolder('Editing');
    folderEditing.add({ 'Move tool': 'T' }, 'Move tool').disable();
    folderEditing.add({ 'Rotate tool': 'R' }, 'Rotate tool').disable();
    folderEditing.add({ 'Scale tool': 'S' }, 'Scale tool').disable();
    folderEditing.add({ 'Snapping off': 'SHIFT' }, 'Snapping off').disable();
    folderEditing.add({ 'Switch transform orientation': 'Q' }, 'Switch transform orientation').disable();



}

async function updateCommandGUI() {
    let textarea = commandGUI.domElement.getElementsByTagName('textarea')[0];
    textarea.value = minecraftSummonCommandFromObjects();
    textarea.style.height = '';
    textarea.style.height = textarea.scrollHeight + 'px';

}

async function updateSearchGUI(searchTerm) {
    searchGUI.folders[0].destroy();
    const folderResults = searchGUI.addFolder('Results');

    //if (searchTerm === '') {
    //    return
    //}

    const response = await fetch(assetsPath + 'blockstates/blockstates.json');
    const json = await response.json();
    const blockStateList = json['blockstates'];

    for (let blockState of blockStateList) {
        if ((blockState + ' ').includes(searchTerm)) {
            const propResults = {
                'add': async function () {
                    selectBlockDisplay(await addBlockDisplay(blockState));
                    updateElementsGUI();
                    render();
                    updateHistory();
                }
            };
            folderResults.add(propResults, 'add').name(blockState);
        }
    }


}

function updateElementsGUI() {
    elementsGUI.destroy();
    elementsGUI.domElement.id = 'elementsGUI';

    document.getElementById('side_container').insertBefore(elementsGUI.domElement, transformsGUI.domElement);

    for (let object of objects.children) {
        const folderBlockDisplay = elementsGUI.addFolder(object.name);
        folderBlockDisplay.close();
        if (object.selected) {
            folderBlockDisplay.domElement.classList.add('selected');
            if (object.isCollection) {
                folderBlockDisplay.domElement.classList.add('collection');
            }
            folderBlockDisplay.open();
        }
        folderBlockDisplay.onOpenClose(changedGUI => {
            selectBlockDisplay(object);
            control.attach(object);
            updateElementsGUI();
            render();
        });
        const propBlockDisplay = {
            'Delete'() {
                deleteBlockDisplay(object);
                updateElementsGUI();
                render();
            },
            'Duplicate': async function () {
                await duplicateBlockDisplay(object);
                updateElementsGUI();
                render();
            }
        };
        if (object.isBlockDisplay) {
            for (let key of Object.keys(object._possibleVariants)) {

                let controller = folderBlockDisplay.add(
                    object.blockState.variant,
                    key,
                    object._possibleVariants[key]
                );
                controller.onChange(async function (v) {
                    if (v) {
                        object.blockState.variant[key] = v;
                    }
                    await object.updateModel();
                    render();
                    updateElementsGUI();
                });
            }
        }
        folderBlockDisplay.add(propBlockDisplay, 'Duplicate');
        folderBlockDisplay.add(propBlockDisplay, 'Delete');


    }

}

function onWindowResize() {

    const aspect = window.innerWidth / window.innerHeight;

    cameraPersp.aspect = aspect;
    cameraPersp.updateProjectionMatrix();

    cameraOrtho.left = cameraOrtho.bottom * aspect;
    cameraOrtho.right = cameraOrtho.top * aspect;
    cameraOrtho.updateProjectionMatrix();

    renderer.setSize(window.innerWidth, window.innerHeight);

    render();

}

function render() {

    renderer.render(scene, currentCamera);

}



async function addBlockDisplay(blockStateString, addToScene = true) {
    let blockModelGroup = await loadBlockState(blockStateString);

    const box = new THREE.Box3();
    box.setFromCenterAndSize(new THREE.Vector3(0.5 - 0.001, 0.5 - 0.001, 0.5 - 0.001), new THREE.Vector3(1 + 0.001, 1 + 0.001, 1 + 0.001));


    blockModelGroup.position.set(0, 0, 0);
    blockModelGroup.isBlockDisplay = true;

    Object.defineProperty(blockModelGroup, 'selected', sel);

    if (addToScene) {
        objects.add(blockModelGroup);

    }

    return blockModelGroup;
}

function groupBlockDisplays(objectList, name = 'Group', addToScene = true) {
    let group = new THREE.Group();
    group.name = name;
    group.isCollection = true;
    for (let object of objectList) {
        if (addToScene) { objects.remove(object) };
        group.add(object);
        object.selected = false;
    }
    let box = new THREE.Box3().setFromObject(group);
    for (let object of objectList) {
        object.position.set(...object.position.add(box.min.clone().negate()).toArray());
    }
    group.position.add(box.min);

    box = new THREE.BoxHelper(group, 0x00ff00);
    box.isBoundingBox = true;
    box.visible = false;
    group.attach(box);

    Object.defineProperty(group, 'selected', sel);
    group.selected = false;

    if (addToScene) {
        objects.add(group);
    }
    return group;
}

function unGroupBlockDisplays(group) {
    control.detach();
    let objectList = group.getObjectsByProperty('isBlockDisplay', true);
    for (let object of objectList) {
        group.remove(object);
        object.applyMatrix4(group.matrix);
        objects.add(object);
        object.selected = true;
    }
    objects.remove(group);
    return objectList;
}

function toggleGrouping() {
    let selected = objects.getObjectsByProperty('selected', true);
    if (selected.length > 1) {
        for (let object of selected) {
            if (object.isCollection) {
                return;
            }
        }
        groupBlockDisplays(selected).selected = true;
    } else if (currentObject.isCollection) {
        unGroupBlockDisplays(currentObject);
    }
}

function selectBlockDisplay(object) {
    control.detach();
    if (!shiftDown) {
        let selected = objects.getObjectsByProperty('selected', true);
        for (let object of selected) {
            object.selected = false;
        }
    }

    if (object) {
        object.selected = true;
        currentObject = object;
        if (!shiftDown) {
            control.attach(object);
            transformsGUI.show();
        } else {
            transformsGUI.hide();
        }

    } else {
        currentObject = objects;
        control.detach();
        transformsGUI.hide();

    }

}

function deleteBlockDisplay(object) {
    let selected = [];
    if (!object) {
        selected = objects.getObjectsByProperty('selected', true);
    } else {
        selected = [object];
    }
    for (let object of selected) {
        objects.remove(object);
    }
    selectBlockDisplay();
}

async function duplicateBlockDisplay(object, addToScene = true) {
    control.detach();
    let objectsToDuplicate = [];
    let objectDuplicates = [];
    if (!object) {
        objectsToDuplicate = objects.getObjectsByProperty('selected', true);
    } else if (Array.isArray(object)) {
        objectsToDuplicate = object;
    } else {
        objectsToDuplicate.push(object);
    }
    for (let object of objectsToDuplicate) {
        if (object.isBlockDisplay) {
            const newObject = await addBlockDisplay(object.name, true);
            newObject.applyMatrix4(object.matrix);
            newObject.updateMatrix();
            objects.remove(newObject);
            objectDuplicates.push(newObject);

        } else if (object.isCollection) {
            let dupliObjectList = await duplicateBlockDisplay(object.children, false);
            const newGroup = groupBlockDisplays(dupliObjectList, object.name, false);
            newGroup.applyMatrix4(object.matrix);
            objects.remove(newGroup);
            objectDuplicates.push(newGroup);
        }
    }
    if (addToScene) {
        for (let object of objectDuplicates) {
            objects.add(object);
        }
    }

    return objectDuplicates;
}

function updateHistory() {
    if (history.length) {
        history = history.slice(0, historyIndex + 1);
        history.push(objects.deepClone());
        historyIndex += 1;
        if (history.length > historyMaxLength) {
            history.shift();
        }
    } else {
        history.push(objects.deepClone());
        historyIndex += 1;
    }
}

function undo() {
    console.log(history);
    console.log(historyIndex);
    control.detach();
    if (historyIndex - 1 < 0) { return }
    historyIndex -= 1;
    scene.remove(objects);
    objects = history[historyIndex].deepClone();
    scene.add(objects);
    render();
}

function redo() {
    console.log(history);
    console.log(historyIndex);
    control.detach();
    if (historyIndex + 1 === historyMaxLength || historyIndex + 1 === history.length) { return }
    historyIndex += 1;
    scene.remove(objects);
    objects = history[historyIndex].deepClone();
    scene.add(objects);
    render();
}

function minecraftSummonCommandFromObjects() {
    let command = '/summon block_display ~-0.5 ~-0.5 ~-0.5 {Passengers:[';
    let passengers = '';
    for (let object of objects.getObjectsByProperty('isBlockDisplay', true)) {
        passengers += '{id:\"minecraft:block_display\",';
        passengers += 'block_state:'
        const { name, variant } = blockStateStringParser(object.name);
        passengers += '{Name:\"' + name + '\"';
        if (Object.keys(variant).length === 0) {

        } else {
            passengers += ',Properties:{';
            for (let property of Object.keys(variant)) {
                passengers += property + ':\"' + variant[property] + '\",';
            }
            passengers = passengers.slice(0, -1);
            passengers += '}';
        }
        passengers += '},';
        passengers += 'transformation:'
        let matrix = object.matrixWorld.clone();
        let array = matrix.transpose().toArray();
        //array.forEach(function(part, index, theArray) {
        //    theArray[index] = theArray[index].toFixed(4);
        //  });
        passengers += JSON.stringify(array).replaceAll(',', 'f,').replace(']', 'f]')
        passengers += '},'
    }
    command += passengers.slice(0, -1);
    command += ']}';
    return command;
}

async function saveBlockDisplaysToFile() {
    let compressed = await compressJSON(objectsToJSON())
    // Create a programmatic download link
    const elem = window.document.createElement("a");
    elem.href = window.URL.createObjectURL(new Blob([compressed]));
    elem.download = 'block_display_model';
    document.body.appendChild(elem);
    elem.click();
    document.body.removeChild(elem);


}

function loadBlockDisplaysFromFile() {
    var input = document.createElement('input');
    input.type = 'file';

    input.onchange = e => {

        // getting a hold of the file reference
        var file = e.target.files[0];

        // setting up the reader
        var reader = new FileReader();
        reader.readAsText(file, 'UTF-8');

        // here we tell the reader what to do when it's done reading...
        reader.onload = async readerEvent => {
            var content = readerEvent.target.result; // this is the content!
            await objectsFromJSON(await decompressJSON(content));
            render();
            updateElementsGUI();
        }

    }

    input.click();
}

function objectsToJSON() {
    let list = [];
    for (let object of objects.children) {
        if (object.isBlockDisplay) {
            let dict = {
                name: object.name,
                transforms: object.matrix.clone().transpose().toArray(),
            };
            list.push(dict);
        } else if (object.isCollection) {
            let groupList = [];
            for (let child of object.getObjectsByProperty('isBlockDisplay', true)) {
                let dict = {
                    name: child.name,
                    transforms: child.matrix.clone().transpose().toArray(),
                };
                groupList.push(dict);
            }
            let dict = {
                nam: object.name,
                transforms: object.matrix.clone().transpose().toArray(),
                children: groupList,
            };
            list.push(dict);
        }
    }
    return JSON.stringify(list);
}

async function objectsFromJSON(string, addToScene = true) {
    const data = JSON.parse(string);
    let newObjects = []
    for (let dict of data) {
        let { name, transforms, children } = dict;
        if (!children) {
            let newObject = await addBlockDisplay(name);
            let matrix = new THREE.Matrix4();
            matrix.set(...transforms);
            newObject.applyMatrix4(matrix);
            newObjects.push(newObject);
        } else {
            let objectList = [];
            for (let child of children) {
                let { name, transforms, children } = child;
                let newObject = await addBlockDisplay(name);
                let matrix = new THREE.Matrix4();
                matrix.set(...transforms);
                newObject.applyMatrix4(matrix);
                objectList.push(newObject);
            }

            const newGroup = groupBlockDisplays(objectList, name, false);
            let matrix = new THREE.Matrix4();
            matrix.set(...transforms);
            newGroup.applyMatrix4(matrix);
            newObjects.push(newGroup);
        }
    }
    if (addToScene) {
        for (let object of newObjects) {
            objects.add(object);
            object.selected = false;

        }
    }

    return newObjects;
}

async function compressJSON(string) {
    // Convert JSON to Stream
    const stream = new Blob([string], {
        type: 'application/json',
    }).stream();
    // gzip stream
    const compressedReadableStream = stream.pipeThrough(
        new CompressionStream("gzip")
    );
    // create Response
    const compressedResponse = await new Response(compressedReadableStream);

    // Get response Blob
    const blob = await compressedResponse.blob();
    // Get the ArrayBuffer
    const buffer = await blob.arrayBuffer();

    // convert ArrayBuffer to base64 encoded string
    const compressedBase64 = btoa(
        String.fromCharCode(
            ...new Uint8Array(buffer)
        )
    );

    return compressedBase64;
}

async function decompressJSON(compressedBase64) {
    // base64 encoding to Blob
    const stream = new Blob([b64decode(compressedBase64)], {
        type: "application/json",
    }).stream();
    const compressedReadableStream = stream.pipeThrough(
        new DecompressionStream("gzip")
    );
    const resp = await new Response(compressedReadableStream);
    const blob = await resp.blob();
    const string = await blob.text()
    return string;
}

function b64decode(str) {
    const binary_string = window.atob(str);
    const len = binary_string.length;
    const bytes = new Uint8Array(new ArrayBuffer(len));
    for (let i = 0; i < len; i++) {
        bytes[i] = binary_string.charCodeAt(i);
    }
    return bytes;
}

function printSceneGraph() {
    scene.traverse(function (obj) {

        var s = '|___';

        var obj2 = obj;

        while (obj2 !== scene) {

            s = '\t' + s;

            obj2 = obj2.parent;

        }

        console.log(s + obj.name + ' <' + obj.type + '>');

    });
}

function arrayEquals(a, b) {
    return Array.isArray(a) &&
        Array.isArray(b) &&
        a.length === b.length &&
        a.every((val, index) => val === b[index]);
}



THREE.Object3D.prototype.deepClone = function (recursive) {

    return new this.constructor().deepCopy(this, recursive);

}
THREE.Object3D.prototype.deepCopy = function (source, recursive) {

    if (recursive === undefined) recursive = true;

    this.isObject3D = source.isObject3D;

    if (source.isBlockDisplay) {
        this.isBlockDisplay = source.isBlockDisplay;
        
        Object.assign(this, bs);
        this._blockState = source._blockState;
        this._possibleVariants = source._possibleVariants;
        
        Object.defineProperty(this, 'selected', sel);
    }
    if (source.isBoundingBox) {
        this.isBoundingBox = source.isBoundingBox;
    }
    if (source.isCollection) {
        this.isCollection = source.isCollection;
    }

    if (source.box) {
        this.box = source.box;
    }

    this.name = source.name;

    this.up.copy(source.up);

    this.position.copy(source.position);
    this.quaternion.copy(source.quaternion);
    this.scale.copy(source.scale);

    this.matrix.copy(source.matrix);
    this.matrixWorld.copy(source.matrixWorld);
    if (source.material) {

            //changed
            if (Array.isArray(source.material)) {
                this.material = source.material;
                for (let material of this.material) {
                    material = material.clone();
                }
            } else {
                this.material = source.material.clone();
            }

    }
    if (source.geometry) {
        //changed
        this.geometry = source.geometry.clone()
    }
    this.matrixAutoUpdate = source.matrixAutoUpdate;
    this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;

    this.layers.mask = source.layers.mask;
    this.visible = source.visible;

    this.castShadow = source.castShadow;
    this.receiveShadow = source.receiveShadow;

    this.frustumCulled = source.frustumCulled;
    this.renderOrder = source.renderOrder;

    this.userData = JSON.parse(JSON.stringify(source.userData));

    if (recursive) {
        this.children = [];
        for (let child of source.children) {

            this.children.push(child.deepClone());

        }

    }

    return this
}